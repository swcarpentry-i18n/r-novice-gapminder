---
title: Data Frame Manipulation with tidyr
teaching: 30
exercises: 15
source: Rmd
---

::::::::::::::::::::::::::::::::::::::: objectives

- To understand the concepts of 'longer' and 'wider' data frame formats and be able to convert between them with `tidyr`.

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: questions

- How can I change the layout of a data frame?

::::::::::::::::::::::::::::::::::::::::::::::::::

```{r, include=FALSE}
gapminder <- read.csv("data/gapminder_data.csv", header = TRUE, stringsAsFactors = FALSE)
gap_wide <- read.csv("data/gapminder_wide.csv", header = TRUE, stringsAsFactors = FALSE)
```

研究者には「横長」データを「縦長」データに（又はその逆を）したいと 思うことがよくあります。 「縦長」形式とは：

- 各列が変数
- 各行が観測値

「縦長」形式では、普通、観測値は１列で、残りの列はIDの変数になります。

For the 'wide' format each row is often a site/subject/patient and you have
multiple observation variables containing the same type of data. These can be
either repeated observations over time, or observation of multiple variables (or
a mix of both). You may find data input may be simpler or some other
applications may prefer the 'wide' format. However, many of `R`'s functions have
been designed assuming you have 'longer' formatted data. This tutorial will help you
efficiently transform your data shape regardless of original format.

![](fig/14-tidyr-fig1.png){alt='Diagram illustrating the difference between a wide versus long layout of a data frame'}

Long and wide data frame layouts mainly affect readability. For humans, the wide format is often more intuitive since we can often see more of the data on the screen due
to its shape. However, the long format is more machine readable and is closer
to the formatting of databases. The ID variables in our data frames are similar to
the fields in a database and observed variables are like the database values.

## 手始めに

まず、パッケージをインストールしましょう、もしまだやっていなければですが （おそらく、前の dplyr のレッスンで、インストールしているかと思います）：

```{r, eval=FALSE}
#install.packages("tidyr")
#install.packages("dplyr")
```

パーッケージをロードしましょう。

```{r, message=FALSE}
library("tidyr")
library("dplyr")
```

始めに、そもそもの gapminder データフレームのデータ構造を見てみましょう：

```{r}
str(gapminder)
```

:::::::::::::::::::::::::::::::::::::::  challenge

## チャレンジ１

gapminder は、横長のみ、縦長のみ、又はその中間の形式でしょうか。

:::::::::::::::  solution

## チャレンジ３の解答

チャレンジ１の解答 元々の gapminder data.frame は、中間の形式です。 複数の観測変数（`pop`,`lifeExp`,`gdpPercap`）があるため、 縦長のみのデータとは言えません。

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

Sometimes, as with the gapminder dataset, we have multiple types of observed
data. It is somewhere in between the purely 'long' and 'wide' data formats. We
have 3 "ID variables" (`continent`, `country`, `year`) and 3 "Observation
variables" (`pop`,`lifeExp`,`gdpPercap`). This intermediate format can be
preferred despite not having ALL observations in 1 column given that all 3
observation variables have different units. There are few operations that would
need us to make this data frame any longer (i.e. 4 ID variables and 1
Observation variable).

While using many of the functions in R, which are often vector based, you
usually do not want to do mathematical operations on values with different
units. For example, using the purely long format, a single mean for all of the
values of population, life expectancy, and GDP would not be meaningful since it
would return the mean of values with 3 incompatible units. The solution is that
we first manipulate the data either by grouping (see the lesson on `dplyr`), or
we change the structure of the data frame.  **Note:** Some plotting functions in
R actually work better in the wide format data.

## gather() を使って、横長から縦長形式へ

Until now, we've been using the nicely formatted original gapminder dataset, but
'real' data (i.e. our own research data) will never be so well organized. Here
let's start with the wide formatted version of the gapminder dataset.

> Download the wide version of the gapminder data from [this link to a csv file](data/gapminder_wide.csv)
> and save it in your data folder.

We'll load the data file and look at it. データファイルをロードして見てみましょう。 注：大陸と国の列は、因子型にはしたくありません。 そこで、そうならないように、`read.csv()`に stringsAsFactors 引数を使いましょう。

```{r}
gap_wide <- read.csv("data/gapminder_wide.csv", stringsAsFactors = FALSE)
str(gap_wide)
```

![](fig/14-tidyr-fig2.png){alt='Diagram illustrating the wide format of the gapminder data frame'}

To change this very wide data frame layout back to our nice, intermediate (or longer) layout, we will use one of the two available `pivot`  functions from the `tidyr` package. To convert from wide to a longer format, we will use the `pivot_longer()` function. `pivot_longer()` makes datasets longer by increasing the number of rows and decreasing the number of columns, or 'lengthening' your observation variables into a single variable.

![](fig/14-tidyr-fig3.png){alt='Diagram illustrating how pivot longer reorganizes a data frame from a wide to long format'}

```{r}
gap_long <- gap_wide %>%
  pivot_longer(
    cols = c(starts_with('pop'), starts_with('lifeExp'), starts_with('gdpPercap')),
    names_to = "obstype_year", values_to = "obs_values"
  )
str(gap_long)
```

ここでは、以前 dplyr のレッスンの中で行ったようなパイプの書き方を使いました。 実は、tidyr と dplyr 関数は互換性があり、パイプで繋ぐことで、一緒に使うことが できるのです。

We first provide to `pivot_longer()` a vector of column names that will be
pivoted into longer format. We could type out all the observation variables, but
as in the `select()` function (see `dplyr` lesson), we can use the `starts_with()`
argument to select all variables that start with the desired character string.
`pivot_longer()` also allows the alternative syntax of using the `-` symbol to
identify which variables are not to be pivoted (i.e. ID variables).

The next arguments to `pivot_longer()` are `names_to` for naming the column that
will contain the new ID variable (`obstype_year`) and `values_to` for naming the
new amalgamated observation variable (`obs_value`). We supply these new column
names as strings.

![](fig/14-tidyr-fig4.png){alt='Diagram illustrating the long format of the gapminder data'}

```{r}
gap_long <- gap_wide %>%
  pivot_longer(
    cols = c(-continent, -country),
    names_to = "obstype_year", values_to = "obs_values"
  )
str(gap_long)
```

これは、このデータフレームでは、取るに足らないことかもしれませんが、 １つの ID 変数と40の変則的な変数名を持つ観測変数がある場合も時にはあります。 柔軟性があることで、かなり時間が節約できるのです！

Now `obstype_year` actually contains 2 pieces of information, the observation
type (`pop`,`lifeExp`, or `gdpPercap`) and the `year`. We can use the
`separate()` function to split the character strings into multiple variables

```{r}
gap_long <- gap_long %>% separate(obstype_year, into = c('obs_type', 'year'), sep = "_")
gap_long$year <- as.integer(gap_long$year)
```

:::::::::::::::::::::::::::::::::::::::  challenge

## チャレンジ２

Using `gap_long`, calculate the mean life expectancy, population, and gdpPercap for each continent.
**Hint:** use the `group_by()` and `summarize()` functions we learned in the `dplyr` lesson

:::::::::::::::  solution

## チャレンジ３の解答

```{r}
gap_long %>% group_by(continent, obs_type) %>%
   summarize(means=mean(obs_values))
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## spread() で縦長から中間形式へ

It is always good to check work. So, let's use the second `pivot` function, `pivot_wider()`, to 'widen' our observation variables back out.  `pivot_wider()` is the opposite of `pivot_longer()`, making a dataset wider by increasing the number of columns and decreasing the number of rows. We can use `pivot_wider()` to pivot or reshape our `gap_long` to the original intermediate format or the widest format. Let's start with the intermediate format.

The `pivot_wider()` function takes `names_from` and `values_from` arguments.

To `names_from` we supply the column name whose contents will be pivoted into new
output columns in the widened data frame. The corresponding values will be added
from the column named in the `values_from` argument.

```{r}
gap_normal <- gap_long %>%
  pivot_wider(names_from = obs_type, values_from = obs_values)
dim(gap_normal)
dim(gapminder)
names(gap_normal)
names(gapminder)
```

元々の `gapminder` と同じ次元を持つ、中間形式のデータフレーム `gap_normal` ができましたが、 変数の順番が違います。 このふたつが、 `all.equal()` かを調べる前に、これを直しましょう。

```{r}
gap_normal <- gap_normal[, names(gapminder)]
all.equal(gap_normal, gapminder)
head(gap_normal)
head(gapminder)
```

もうすぐです。元々のは、 `country` 、 `continent` 、そして `year` でソートされていました。

```{r}
gap_normal <- gap_normal %>% arrange(country, year)
all.equal(gap_normal, gapminder)
```

That's great! すばらしい！一番縦に長い形式から、中間形式に戻し、コードにエラーが でることもありませんでした。

Now let's convert the long all the way back to the wide. In the wide format, we
will keep country and continent as ID variables and pivot the observations
across the 3 metrics (`pop`,`lifeExp`,`gdpPercap`) and time (`year`). First we
need to create appropriate labels for all our new variables (time\*metric
combinations) and we also need to unify our ID variables to simplify the process
of defining `gap_wide`.

```{r}
gap_temp <- gap_long %>% unite(var_ID, continent, country, sep = "_")
str(gap_temp)

gap_temp <- gap_long %>%
    unite(ID_var, continent, country, sep = "_") %>%
    unite(var_names, obs_type, year, sep = "_")
str(gap_temp)
```

`unite()` を使い、`continent`と`country`を組み合わせ、ID 変数をひとつ作り、 変数名を定義しました。 `spread()` でパイプを使う準備が整いました。

```{r}
gap_wide_new <- gap_long %>%
  unite(ID_var, continent, country, sep = "_") %>%
  unite(var_names, obs_type, year, sep = "_") %>%
  pivot_wider(names_from = var_names, values_from = obs_values)
str(gap_wide_new)
```

:::::::::::::::::::::::::::::::::::::::  challenge

## チャレンジ３

この一つ先に進み、 `gap_ludicrously_wide` を作り、国、年及び３つの行列に展開したデータを作りましょう。
ヒント この新しいデータフレームには、５行しかありません。

:::::::::::::::  solution

## チャレンジ３の解答

```{r}
gap_ludicrously_wide <- gap_long %>%
   unite(var_names, obs_type, year, country, sep = "_") %>%
   pivot_wider(names_from = var_names, values_from = obs_values)
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

今、とても '横長な' 形式のデータフレームがありますが、 `ID_var` は、より使えるようにできるはずです。 `separate()` を使って、２変数に分けてみましょう。

```{r}
gap_wide_betterID <- separate(gap_wide_new, ID_var, c("continent", "country"), sep="_")
gap_wide_betterID <- gap_long %>%
    unite(ID_var, continent, country, sep = "_") %>%
    unite(var_names, obs_type, year, sep = "_") %>%
    pivot_wider(names_from = var_names, values_from = obs_values) %>%
    separate(ID_var, c("continent","country"), sep = "_")
str(gap_wide_betterID)

all.equal(gap_wide, gap_wide_betterID)
```

そこにまた戻りました！

## その他役に立つ資料

- [R for Data Science](https://r4ds.hadley.nz/) (online book)
- [Data Wrangling Cheat sheet](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf) (pdf file)
- [Introduction to tidyr](https://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html) (online documentation)
- [Data wrangling with R and RStudio](https://www.rstudio.com/resources/webinars/data-wrangling-with-r-and-rstudio/) (online video)

:::::::::::::::::::::::::::::::::::::::: keypoints

- Use the `tidyr` package to change the layout of data frames.
- Use `pivot_longer()` to go from wide to longer layout.
- Use `pivot_wider()` to go from long to wider layout.

::::::::::::::::::::::::::::::::::::::::::::::::::
